import JSZip from "jszip";
import { Logger } from "./logger";
import type { UploadedFile, FileAnalysis, BuildOptions } from "../types";

// --- Template File Builder dari Kerangka Fase 1 ---

const compileScript = (): string => `
// compile-project.js
// SAT18 Engine – Local Compiler

const { execSync } = require('child_process');

console.log("🧩 [SAT18] Installing dependencies...");
try {
  execSync('npm install', { stdio: 'inherit' });
} catch (e) {
  console.error("❌ [SAT18] Dependency installation failed. Please check the error log above.");
  process.exit(1);
}

console.log("⚙️ [SAT18] Building project assets...");
try {
  execSync('npm run build', { stdio: 'inherit' });
} catch (e) {
  console.error("❌ [SAT18] Project build failed. Check your build script in package.json.");
  process.exit(1);
}

console.log("✅ [SAT18] Build complete. Files are ready in /dist folder.");
`.trim();


const buildApkScript = (): string => `
// build-apk.js
// SAT18 Engine – Local APK Builder

const { execSync } = require('child_process');
const fs = require('fs');

console.log("📦 [SAT18] Preparing Android project via Capacitor...");

if (!fs.existsSync('./android')) {
    try {
        console.log("   > Android platform not found. Running 'npx cap add android'...");
        execSync('npx cap add android', { stdio: 'inherit' });
    } catch(e) {
        console.error("❌ [SAT18] Failed to add Android platform. Please ensure Capacitor is installed correctly and run 'npm install' first.");
        process.exit(1);
    }
}

try {
    console.log("   > Syncing web assets with Android project...");
    execSync('npx cap sync android', { stdio: 'inherit' });
} catch (e) {
    console.error("❌ [SAT18] Failed to sync Capacitor project. Please check for errors above.");
    process.exit(1);
}

console.log("🔨 [SAT18] Building Android APK via Gradle...");
try {
    const gradlew = process.platform === 'win32' ? 'gradlew.bat' : './gradlew';
    execSync(\`cd android && \${gradlew} assembleDebug\`, { stdio: 'inherit' });
} catch (e) {
    console.error("❌ [SAT18] APK build failed. Ensure you have the Android SDK and Gradle configured correctly.");
    console.error("   > Tip: Try running 'npx cap open android' to debug the project in Android Studio.");
    process.exit(1);
}

console.log("✅ [SAT18] APK build finished. Check '/android/app/build/outputs/apk/debug/'");
`.trim();


const deployLocalScript = (): string => `
// deploy-local.js - Generated by SAT18 Engine v2
// Automates deployment with atomic symlinks, health checks, and rollbacks.

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// --- Configuration ---
// Adjust these paths for your server environment.
const BASE_PATH = path.resolve('/var/www/sat18');
const RELEASES_DIR = path.join(BASE_PATH, 'releases');
const CURRENT_SYMLINK = path.join(BASE_PATH, 'current');
const STATE_FILE = path.join(BASE_PATH, 'deployment-state.json');
const ARTIFACT_PATH = path.resolve('./sat18-deployment.zip'); // Assumes script runs where zip is uploaded

// --- Logging ---
const log = (level, message) => {
  const prefixMap = { info: 'INFO', success: 'SUCCESS', error: 'ERROR', warn: 'WARN' };
  const prefix = prefixMap[level] || 'LOG';
  // This format is parsed by the SAT18 Log Streamer.
  console.log(\`[SAT18-DEPLOY][\${prefix}] \${message}\`);
};

// --- State Management ---
const readState = () => {
  if (!fs.existsSync(STATE_FILE)) return { lastSuccessful: null, history: [] };
  try {
    return JSON.parse(fs.readFileSync(STATE_FILE, 'utf8'));
  } catch {
    return { lastSuccessful: null, history: [] };
  }
};

const writeState = (state) => {
  fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2), 'utf8');
};

// --- Core Functions ---
const run = (command, cwd) => {
  log('info', \`Executing: \${command}\`);
  execSync(command, { stdio: 'inherit', cwd });
};

const rollback = (lastSuccessfulPath, state) => {
  log('warn', 'Deployment failed. Rolling back to last successful version...');
  if (lastSuccessfulPath && fs.existsSync(lastSuccessfulPath)) {
    run(\`ln -sfn \${lastSuccessfulPath} \${CURRENT_SYMLINK}\`);
    log('success', \`Rollback complete. '\${CURRENT_SYMLINK}' now points to '\${lastSuccessfulPath}'.\`);
  } else {
    log('error', 'No successful previous version found to roll back to. Manual intervention required.');
    if (fs.existsSync(CURRENT_SYMLINK)) fs.unlinkSync(CURRENT_SYMLINK); // Remove broken symlink
  }
  process.exit(1);
};

const cleanupOldReleases = (currentState) => {
  const releasesToKeep = 5;
  const currentReleaseName = currentState.lastSuccessful ? path.basename(currentState.lastSuccessful.path) : null;

  try {
    const releases = fs.readdirSync(RELEASES_DIR)
      .map(name => ({ name, path: path.join(RELEASES_DIR, name), stat: fs.statSync(path.join(RELEASES_DIR, name)) }))
      .sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());

    if (releases.length > releasesToKeep) {
      log('info', \`Cleaning up old releases. Keeping the latest \${releasesToKeep}.\`);
      const releasesToDelete = releases.slice(releasesToKeep);
      releasesToDelete.forEach(release => {
        // Double-check we are not deleting the active release
        if (release.name !== currentReleaseName) {
            log('info', \` > Deleting old release: \${release.name}\`);
            fs.rmSync(release.path, { recursive: true, force: true });
        }
      });
    }
  } catch (error) {
      log('warn', \`Could not clean up old releases: \${error.message}\`);
  }
};

// --- Main Deployment Flow ---
const main = () => {
  const state = readState();
  const lastSuccessfulPath = state.lastSuccessful?.path;
  const releaseId = new Date().toISOString().replace(/[:.]/g, '-');
  const releasePath = path.join(RELEASES_DIR, releaseId);
  const newHistoryEntry = { version: releaseId, status: 'failed', startedAt: new Date().toISOString() };

  try {
    log('info', \`Starting deployment for release: \${releaseId}\`);

    // 1. Setup directories and ensure artifact exists
    fs.mkdirSync(releasePath, { recursive: true });
    if (!fs.existsSync(ARTIFACT_PATH)) throw new Error(\`Artifact not found at \${ARTIFACT_PATH}\`);

    // 2. Unpack artifact
    run(\`unzip -o \${ARTIFACT_PATH} -d \${releasePath}\`);

    // 3. Install dependencies & build project (if needed)
    if (fs.existsSync(path.join(releasePath, '_config.yml'))) {
        log('info', 'Jekyll project detected. Running build process...');
        if (fs.existsSync(path.join(releasePath, 'Gemfile'))) {
            run('bundle install', releasePath);
            run('bundle exec jekyll build', releasePath);
        } else {
            log('warn', 'No Gemfile found. Attempting to build with system Jekyll.');
            run('jekyll build', releasePath);
        }
    } else if (fs.existsSync(path.join(releasePath, 'package.json'))) {
      log('info', 'Node.js project detected. Running build process...');
      run('npm install --production', releasePath);
      const pkg = JSON.parse(fs.readFileSync(path.join(releasePath, 'package.json'), 'utf-8'));
      if (pkg.scripts && pkg.scripts.build) {
        run('npm run build', releasePath);
      }
    }

    // 4. Perform health check
    log('info', 'Performing health check...');
    let buildOutputDir = '';
    if (fs.existsSync(path.join(releasePath, '_site'))) {
        buildOutputDir = '_site';
    } else if (fs.existsSync(path.join(releasePath, 'dist'))) {
        buildOutputDir = 'dist';
    }
    
    const entryPointPath = path.join(releasePath, buildOutputDir, 'index.html');
    if (!fs.existsSync(entryPointPath) && !fs.existsSync(path.join(releasePath, 'index.html'))) {
      throw new Error(\`Health check failed: index.html not found in standard build directories ('_site/', 'dist/') or project root.\`);
    }
    log('success', 'Health check passed.');

    // 5. Activate new release (atomic symlink switch)
    log('info', \`Activating new release by updating symlink... \`);
    run(\`ln -sfn \${releasePath} \${CURRENT_SYMLINK}\`);

    // 6. Update state
    state.lastSuccessful = { version: releaseId, path: releasePath, deployedAt: new Date().toISOString() };
    newHistoryEntry.status = 'success';
    state.history = [newHistoryEntry, ...state.history].slice(0, 10); // Keep last 10 records
    writeState(state);
    log('success', \`Deployment successful! '\${path.basename(CURRENT_SYMLINK)}' is now live.\`);

    // 7. Cleanup
    cleanupOldReleases(state);

  } catch (error) {
    log('error', \`Deployment failed: \${error.message}\`);
    if (fs.existsSync(releasePath)) {
      log('info', \`Cleaning up failed release directory: \${releasePath}\`);
      fs.rmSync(releasePath, { recursive: true, force: true });
    }
    state.history = [newHistoryEntry, ...state.history].slice(0, 10);
    writeState(state);
    rollback(lastSuccessfulPath, state);
  }
};

main();
`.trim();


const getPackageJson = (appName: string): string => {
  const formattedAppName = appName.toLowerCase().replace(/\s+/g, '-');
  return JSON.stringify({
    "name": formattedAppName,
    "version": "1.0.0",
    "private": true,
    "description": "SAT18 Build-Ready Kit",
    "scripts": {
      "build": "echo \"Building static files...\" && mkdir -p dist && cp -r src/* dist/"
    },
    "dependencies": {
      "@capacitor/core": "^6.0.0",
      "@capacitor/android": "^6.0.0",
      "@capacitor/ios": "^6.0.0"
    },
    "devDependencies": {
      "@capacitor/cli": "^6.0.0"
    }
  }, null, 2);
};

const getCapacitorConfig = (appName: string): string => {
    const appId = `com.sat18.${appName.toLowerCase().replace(/\s+/g, '')}`;
    return JSON.stringify({
      "appId": appId,
      "appName": appName,
      "webDir": "dist",
      "bundledWebRuntime": false
    }, null, 2);
};

const getReadme = (): string => `
# SAT18 Build-Ready Kit

Selamat datang di paket build lokal SAT18 Engine.

## 🚀 Langkah Cepat
1. Extract file .zip ini.
2. Buka terminal di dalam folder hasil extract.
3. Jalankan perintah berikut secara berurutan:
   \`\`\`bash
   # Install semua dependencies (Capacitor, dll.)
   npm install

   # Jalankan skrip untuk mem-build aset web Anda (dari /src ke /dist)
   node builder/compile-project.js

   # (Opsional) Build file APK untuk Android
   node builder/build-apk.js
   \`\`\`

File APK akan muncul di: \`/android/app/build/outputs/apk/debug/\`

## 🧠 Catatan
- Anda bebas memodifikasi skrip di dalam folder \`/builder\`.
- Pastikan Node.js, NPM, dan lingkungan pengembangan Android (Android Studio) atau iOS (Xcode) sudah terinstall di sistem Anda.

Dibuat dengan ❤️ oleh **Sat18 Official**
`;

/**
 * Creates a platform-specific build package (.zip) from the analyzed project structure.
 * This function runs entirely in the browser and is 100% offline.
 *
 * @param originalFiles - The original uploaded files with their content.
 * @param analysisFiles - The analysis result with the new suggested paths.
 * @param options - Configuration for the build, including app name and target platform.
 * @returns A Promise that resolves to a Blob of the generated .zip file.
 */
export async function prepareBuild(
  originalFiles: UploadedFile[],
  analysisFiles: FileAnalysis[],
  options: BuildOptions
): Promise<Blob> {
  const zip = new JSZip();
  const fileMap = new Map(originalFiles.map(f => [f.name, f.content]));
  const { target, appName } = options;
  
  Logger.log('info', `Preparing build for target '${target}' with app name '${appName}'...`);

  if (target === "android" || target === "ios") {
    Logger.log('info', `Creating a Capacitor Build-Ready Kit for '${target}'...`);
    
    // 1. Add analyzed project files to their respective locations.
    analysisFiles.forEach(analysis => {
      // We are generating a new package.json and capacitor config, so skip the old one.
      if (analysis.originalPath.endsWith('package.json') || analysis.originalPath.endsWith('capacitor.config.ts') || analysis.originalPath.endsWith('capacitor.config.json')) {
          return;
      }
      const content = fileMap.get(analysis.originalPath);
      if (content !== undefined) {
        zip.file(analysis.suggestedPath, content);
      }
    });
    Logger.log('info', ` > Added analyzed files to the project structure.`);

    // 2. Add the builder scripts
    const builder = zip.folder("builder");
    if(builder){
        builder.file("compile-project.js", compileScript());
        builder.file("build-apk.js", buildApkScript());
        builder.file("deploy-local.js", deployLocalScript());
        Logger.log('info', ' > Added /builder directory with helper scripts.');
    }

    // 3. Add/overwrite configuration and documentation files
    zip.file("capacitor.config.json", getCapacitorConfig(appName));
    zip.file("package.json", getPackageJson(appName));
    zip.file("README.md", getReadme());
    Logger.log('info', ' > Added capacitor.config.json, package.json, and README.md.');
    Logger.log('success', 'Build-Ready Kit structure is ready for packaging.');

  } else { // Web target (PWA or static site like Jekyll)
    analysisFiles.forEach(analysis => {
      const content = fileMap.get(analysis.originalPath);
      if (content !== undefined) {
        zip.file(analysis.suggestedPath, content);
      }
    });
    // For a 'web' deploy, the zip contains the source. The special deploy-local.js
    // script is now part of the server logic, not this package. So we add PWA files.
    Logger.log('info', `Adding platform-specific files for 'web'...`);
    const manifestJson = {
      name: appName,
      short_name: appName,
      start_url: "./index.html",
      display: "standalone",
      background_color: "#0A0A0A",
      theme_color: "#00BFFF"
    };
    zip.file("manifest.json", JSON.stringify(manifestJson, null, 2));
    Logger.log('info', ` > Added manifest.json for PWA capabilities.`);
  }

  // Generate the final .zip file as a Blob.
  Logger.log('info', `Compressing files into final .zip package...`);
  return await zip.generateAsync({ type: "blob" });
}